#!/usr/bin/env python3

# A util script that aims to ease use `zig cc` to compile C/C++/Rust/Go programs.
#
# How it works:
# This script will infer which command to run based on `sys.argv[0]`, which is
# the program name, currently it supports:
# 1. zigcc, invoke `zig cc`
# 2. zigcxx, invoke `zig c++`
# 3. zigcargo, invoke `cargo` with `CC`, `CXX`, and rustc linker set to zig.
#
# Supported env vars:
# 1. `ZIGCC_LOG`, enable log
# 2. `ZIGCC_FLAGS`, extra flags passed to zig, such as `-fno-sanitize=undefined`

import sys, os
import logging
import subprocess

UNKNOWN = 0
RUST = 1
GO = 2
ENABLE_LOG = os.getenv('ZIGCC_LOG') in ['true', '1']

# Update this if zig cc doesn't support specific args.
# Exact match
BLACKLIST_ARGS = ['-no_pie', '-Wl,-no_pie']
# Wild match
BLACKLIST_WILD_ARGS = ['--target',
                       # '-exported_symbols_list',
                       # '-dylib'
                       ]

def log(msg, *args, **kwargs):
    if ENABLE_LOG:
        logging.info(msg, *args, **kwargs)

def zig_target_from(target, lang):
    if lang == RUST:
        # Zig target has no vendor field
        # i686-pc-windows-msvc --> x86-windows-msvc
        [arch, vendor, os, abi] = target.split('-')
        zig_arch = {
            'i686': 'x86',
        }.get(arch, arch)
        return '-'.join([zig_arch, os, abi])
    elif lang == GO:
        [arch, os] = target.split('-', 2)
        zig_arch = {
           "386": "x86",
           "amd64": "x86_64",
           "arm64": "aarch64",
        }.get(arch, arch)
        zig_os = {
            'darwin': 'macos'
        }.get(os, os)
        return '-'.join([zig_arch, zig_os])
    else:
        return target


# Detect zig target from language specific vars.
def detect_zig_target():
    target = os.getenv('CARGO_BUILD_TARGET')
    if target is not None:
        return zig_target_from(target, RUST)

    goos = os.getenv('GOOS')
    if goos is not None:
        goarch = os.getenv('GOARCH')
        return zig_target_from('{}-{}'.format(goarch, goos), GO)

    return None


def cargo_linker_var_name(target):
    return 'CARGO_TARGET_{}_LINKER'.format(target.replace('-', '_').upper())

def guess_rust_target(args):
    found_target = False
    for arg in args:
        if arg == '--target':
            found_target = True
            continue
        if found_target:
            return arg

    target = os.getenv('CARGO_BUILD_TARGET')
    if target is not None:
        return target

    try:
        stdout = subprocess.check_output(['rustc', '-Vv']).decode('utf8')
        for line in stdout.split('\n'):
            kv = line.split(':', 2)
            if len(kv) > 1:
                [key, value] = kv
                if key == 'host':
                    return value.strip()
    except Exception as e:
        log('Get rustc triple failed, err:{}', e)
        raise e

def run_subprocess(args, env):
    log('Begin run command\nArgs:%s\nEnv:%s', args, env)
    try:
        subprocess.run(args,
                       check=True,
                       env=env)
    except subprocess.CalledProcessError as e:
        log(f'Command {e.cmd} failed with error {e.returncode}')
        sys.exit(e.returncode)

def run_as_cargo(args):
    target = guess_rust_target(args)
    env = os.environ.copy()
    env[cargo_linker_var_name(target)] = 'zigcc'
    env['CC'] = 'zigcc'
    env['CXX'] = 'zigcxx'
    run_subprocess(['cargo'] + args, env)

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO,
                        format='%(asctime)s %(message)s')
    program = os.path.basename(sys.argv[0])
    args = sys.argv[1:]
    if program == 'zigcargo':
        run_as_cargo(args)
        sys.exit(0)

    run_args = {
        'zigcc': ['zig', 'cc'],
        'zigcxx': ['zig', 'c++'],
    }.get(program)
    if run_args is None:
        print(f"Unknown program, {program}")
        sys.exit(1)

    target = detect_zig_target()
    if target is not None:
        run_args += ['-target', target]

    flags = os.getenv('ZIGCC_FLAGS')
    if flags is not None:
        for flag in flags.split(' '):
            run_args.append(flag)

    for arg in args:
        if arg in BLACKLIST_ARGS:
            continue

        found = False
        for wild_args in BLACKLIST_WILD_ARGS:
            if wild_args in arg:
                found = True
                break

        if found:
            continue

        run_args.append(arg)

    run_subprocess(run_args, os.environ)
